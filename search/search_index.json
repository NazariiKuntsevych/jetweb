{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Documentation: https://nazariikuntsevych.github.io/jetweb/.</p>"},{"location":"#jetweb","title":"JetWeb","text":"<p>JetWeb is a lightweight Python WSGI-compatible web framework, designed for simplicity, minimalism, and flexibility.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>WSGI-compatible.</li> <li>Zero dependencies.</li> <li>Function-based and class-based request handlers.</li> <li>HTTP exception handlers.</li> <li>Middlewares.</li> <li>Dynamic routing with converters.</li> <li>Dependency injection with request context.</li> <li>Covered by automated tests.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install git+ssh://git@github.com/NazariiKuntsevych/jetweb.git\n</code></pre>"},{"location":"#licensing","title":"Licensing","text":"<p>The code in this project is licensed under MIT license.</p>"},{"location":"overview/","title":"Overview","text":"<p>Here is a simple code example:</p> <pre><code>from jetweb import JetWeb\n\napp = JetWeb(debug=True)\n\n\n@app.get(\"/\")\ndef home() -&gt; str:\n    return \"Welcome to JetWeb!\"\n\n\n@app.get(\"/hello/{name:str}\")\ndef greet(name: str) -&gt; dict:\n    return {\"message\": f\"Hello, {name}!\"}\n\n\n@app.exception_handler(404)\ndef not_found() -&gt; dict:\n    return {\"error\": \"Page not found\"}\n\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000)\n</code></pre> <p>For more examples read Tutorial section.</p>"},{"location":"reference/code-structure/","title":"Code Structure","text":"<p>The code has the following structure:</p> <pre><code>jetweb/\n|-- tests/                # Automated tests\n|-- docs/                 # Documentation\n|-- jetweb/               # Main code\n|---- application.py      # JetWeb application, main WSGI entrypoint\n|---- context.py          # Request context with dependency injection\n|---- converters.py       # Path parameter converters\n|---- exceptions.py       # HTTP exception representation\n|---- handler.py          # Base class for class-based routes\n|---- http/               # HTTP request and response representation\n|---- routing/            # Routing system (router, routes and route table)\n|---- utils/              # Utility functions and datastructures\n</code></pre>"},{"location":"reference/api/application/","title":"application.py","text":"<p>Provides central WSGI application.</p>"},{"location":"reference/api/application/#jetweb.application.JetWeb","title":"<code>JetWeb</code>","text":"<p>               Bases: <code>Router</code></p> <p>Main application class, built on top of Router.</p> <p>Handles incoming WSGI requests, applies middlewares, dispatches routes, and manages exception handling. Provides a simple development server runner.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Optional URL prefix for all routes.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Enables detailed exception output in responses if True.</p> <code>False</code> <code>global_context</code> <code>dict</code> <p>Context values for each request.</p> <code>None</code> Source code in <code>jetweb/application.py</code> <pre><code>class JetWeb(Router):\n    \"\"\"\n    Main application class, built on top of Router.\n\n    Handles incoming WSGI requests, applies middlewares, dispatches routes,\n    and manages exception handling. Provides a simple development server runner.\n\n    :param prefix: Optional URL prefix for all routes.\n    :param debug: Enables detailed exception output in responses if True.\n    :param global_context: Context values for each request.\n    \"\"\"\n\n    def __init__(self, prefix: str = None, debug: bool = False, global_context: dict = None):\n        super().__init__(prefix=prefix)\n        self.debug = debug\n        self.global_context = global_context or {}\n\n    def __call__(self, environ: dict, start_response: Callable) -&gt; Iterable[bytes]:\n        \"\"\"\n        WSGI entry point for handling a request.\n\n        :param environ: WSGI environment dictionary.\n        :param start_response: WSGI callback to start the HTTP response.\n        :returns: Response body as an iterable of bytes.\n        \"\"\"\n        request = Request.from_environ(environ)\n        context = Context(request=request, app=self, **self.global_context)\n        try:\n            response = self.proceed_middlewares(context)\n        except BaseException as exception:\n            response = self.handle_exception(exception, context)\n\n        context.clear()\n        start_response(f\"{response.status} {response.reason}\", list(response.headers.items()))\n        return [response.body]\n\n    def run(self, host: str = \"0.0.0.0\", port: int = 8000) -&gt; None:\n        \"\"\"\n        Start a simple development WSGI server.\n\n        :param host: Host address to bind to.\n        :param port: Port number to listen on.\n        \"\"\"\n        with make_server(host=host, port=port, app=self) as server:\n            print(f\"Running on http://{host}:{port}/\", file=sys.stderr)\n            print(\"Do not use this server in production\", file=sys.stderr)\n            server.serve_forever()\n\n    def proceed_middlewares(self, context: Context) -&gt; Response:\n        \"\"\"\n        Apply middlewares sequentially and resolve the final response.\n\n        :param context: Context values for current request.\n        :returns: Response object.\n        \"\"\"\n        def wrap(middleware: Callable, next_handler: Callable) -&gt; Callable:\n            def handler() -&gt; Response:\n                return Response.ensure_response(middleware(next_handler, **context.params_for(middleware)))\n            return handler\n\n        next_handler = None\n        for middleware in reversed(self.middlewares + [self.handle_request]):\n            next_handler = wrap(middleware, next_handler)\n\n        return next_handler()\n\n    def handle_request(self, next_handler: Callable, context: Context) -&gt; Response:\n        \"\"\"\n        Resolve the request handler for the given endpoint and method.\n\n        :param next_handler: Not used, required for middleware signature.\n        :param context: Context values for current request.\n        :returns: Response object.\n        \"\"\"\n        request = context[\"request\"]\n        handler, path_params = self.route_table.find_handler(request.endpoint, request.method)\n        context.update(**path_params)\n        return handler(**context.params_for(handler))\n\n    def handle_exception(self, exception: BaseException, context: Context) -&gt; Response:\n        \"\"\"\n        Convert an exception into a proper HTTP response.\n\n        :param exception: The raised exception.\n        :param context: Context values for current request.\n        :returns: Response object.\n        \"\"\"\n        http_exception = HTTPException.from_exception(exception, catch_traceback=self.debug)\n        context.update(exception=http_exception)\n\n        exception_handler = self.exception_handlers.get(http_exception.status)\n        if not exception_handler:\n            return http_exception\n\n        try:\n            return Response.ensure_response(\n                exception_handler(**context.params_for(exception_handler))\n            )\n        except BaseException as inner_exception:\n            combined_exception = inner_exception.with_traceback(inner_exception.__traceback__)\n            combined_exception.__cause__ = exception\n            return HTTPException.from_exception(combined_exception, catch_traceback=self.debug)\n</code></pre>"},{"location":"reference/api/application/#jetweb.application.JetWeb.__call__","title":"<code>__call__(environ, start_response)</code>","text":"<p>WSGI entry point for handling a request.</p> <p>Parameters:</p> Name Type Description Default <code>environ</code> <code>dict</code> <p>WSGI environment dictionary.</p> required <code>start_response</code> <code>Callable</code> <p>WSGI callback to start the HTTP response.</p> required <p>Returns:</p> Type Description <code>Iterable[bytes]</code> <p>Response body as an iterable of bytes.</p> Source code in <code>jetweb/application.py</code> <pre><code>def __call__(self, environ: dict, start_response: Callable) -&gt; Iterable[bytes]:\n    \"\"\"\n    WSGI entry point for handling a request.\n\n    :param environ: WSGI environment dictionary.\n    :param start_response: WSGI callback to start the HTTP response.\n    :returns: Response body as an iterable of bytes.\n    \"\"\"\n    request = Request.from_environ(environ)\n    context = Context(request=request, app=self, **self.global_context)\n    try:\n        response = self.proceed_middlewares(context)\n    except BaseException as exception:\n        response = self.handle_exception(exception, context)\n\n    context.clear()\n    start_response(f\"{response.status} {response.reason}\", list(response.headers.items()))\n    return [response.body]\n</code></pre>"},{"location":"reference/api/application/#jetweb.application.JetWeb.handle_exception","title":"<code>handle_exception(exception, context)</code>","text":"<p>Convert an exception into a proper HTTP response.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>BaseException</code> <p>The raised exception.</p> required <code>context</code> <code>Context</code> <p>Context values for current request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Source code in <code>jetweb/application.py</code> <pre><code>def handle_exception(self, exception: BaseException, context: Context) -&gt; Response:\n    \"\"\"\n    Convert an exception into a proper HTTP response.\n\n    :param exception: The raised exception.\n    :param context: Context values for current request.\n    :returns: Response object.\n    \"\"\"\n    http_exception = HTTPException.from_exception(exception, catch_traceback=self.debug)\n    context.update(exception=http_exception)\n\n    exception_handler = self.exception_handlers.get(http_exception.status)\n    if not exception_handler:\n        return http_exception\n\n    try:\n        return Response.ensure_response(\n            exception_handler(**context.params_for(exception_handler))\n        )\n    except BaseException as inner_exception:\n        combined_exception = inner_exception.with_traceback(inner_exception.__traceback__)\n        combined_exception.__cause__ = exception\n        return HTTPException.from_exception(combined_exception, catch_traceback=self.debug)\n</code></pre>"},{"location":"reference/api/application/#jetweb.application.JetWeb.handle_request","title":"<code>handle_request(next_handler, context)</code>","text":"<p>Resolve the request handler for the given endpoint and method.</p> <p>Parameters:</p> Name Type Description Default <code>next_handler</code> <code>Callable</code> <p>Not used, required for middleware signature.</p> required <code>context</code> <code>Context</code> <p>Context values for current request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Source code in <code>jetweb/application.py</code> <pre><code>def handle_request(self, next_handler: Callable, context: Context) -&gt; Response:\n    \"\"\"\n    Resolve the request handler for the given endpoint and method.\n\n    :param next_handler: Not used, required for middleware signature.\n    :param context: Context values for current request.\n    :returns: Response object.\n    \"\"\"\n    request = context[\"request\"]\n    handler, path_params = self.route_table.find_handler(request.endpoint, request.method)\n    context.update(**path_params)\n    return handler(**context.params_for(handler))\n</code></pre>"},{"location":"reference/api/application/#jetweb.application.JetWeb.proceed_middlewares","title":"<code>proceed_middlewares(context)</code>","text":"<p>Apply middlewares sequentially and resolve the final response.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>Context values for current request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Source code in <code>jetweb/application.py</code> <pre><code>def proceed_middlewares(self, context: Context) -&gt; Response:\n    \"\"\"\n    Apply middlewares sequentially and resolve the final response.\n\n    :param context: Context values for current request.\n    :returns: Response object.\n    \"\"\"\n    def wrap(middleware: Callable, next_handler: Callable) -&gt; Callable:\n        def handler() -&gt; Response:\n            return Response.ensure_response(middleware(next_handler, **context.params_for(middleware)))\n        return handler\n\n    next_handler = None\n    for middleware in reversed(self.middlewares + [self.handle_request]):\n        next_handler = wrap(middleware, next_handler)\n\n    return next_handler()\n</code></pre>"},{"location":"reference/api/application/#jetweb.application.JetWeb.run","title":"<code>run(host='0.0.0.0', port=8000)</code>","text":"<p>Start a simple development WSGI server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Host address to bind to.</p> <code>'0.0.0.0'</code> <code>port</code> <code>int</code> <p>Port number to listen on.</p> <code>8000</code> Source code in <code>jetweb/application.py</code> <pre><code>def run(self, host: str = \"0.0.0.0\", port: int = 8000) -&gt; None:\n    \"\"\"\n    Start a simple development WSGI server.\n\n    :param host: Host address to bind to.\n    :param port: Port number to listen on.\n    \"\"\"\n    with make_server(host=host, port=port, app=self) as server:\n        print(f\"Running on http://{host}:{port}/\", file=sys.stderr)\n        print(\"Do not use this server in production\", file=sys.stderr)\n        server.serve_forever()\n</code></pre>"},{"location":"reference/api/context/","title":"context.py","text":"<p>Provides request context for dependency injection.</p>"},{"location":"reference/api/context/#jetweb.context.Context","title":"<code>Context</code>","text":"<p>               Bases: <code>UserDict</code></p> <p>Dictionary-like object that stores request context for dependency injection.</p> Source code in <code>jetweb/context.py</code> <pre><code>class Context(UserDict):\n    \"\"\"\n    Dictionary-like object that stores request context for dependency injection.\n    \"\"\"\n\n    def params_for(self, function: Callable) -&gt; dict:\n        \"\"\"\n        Extract only the parameters from context that a function expects.\n\n        :param function: Callable whose signature will be inspected.\n        :returns: Dictionary of context values relevant to the function.\n        \"\"\"\n        signature = inspect.signature(function).parameters\n        return {\n            name: value\n            for name, value in {\"context\": self, **self.data}.items()\n            if name in signature\n        }\n</code></pre>"},{"location":"reference/api/context/#jetweb.context.Context.params_for","title":"<code>params_for(function)</code>","text":"<p>Extract only the parameters from context that a function expects.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable</code> <p>Callable whose signature will be inspected.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of context values relevant to the function.</p> Source code in <code>jetweb/context.py</code> <pre><code>def params_for(self, function: Callable) -&gt; dict:\n    \"\"\"\n    Extract only the parameters from context that a function expects.\n\n    :param function: Callable whose signature will be inspected.\n    :returns: Dictionary of context values relevant to the function.\n    \"\"\"\n    signature = inspect.signature(function).parameters\n    return {\n        name: value\n        for name, value in {\"context\": self, **self.data}.items()\n        if name in signature\n    }\n</code></pre>"},{"location":"reference/api/converters/","title":"converters.py","text":"<p>Provides converters for dynamic route parameters.</p>"},{"location":"reference/api/converters/#jetweb.converters.BaseConverter","title":"<code>BaseConverter</code>","text":"<p>Base class for route parameter converters.</p> <p>Attributes:</p> Name Type Description <code>pattern</code> <p>Regex pattern to match request endpoint.</p> <code>identifier</code> <p>Identifier used in route endpoint.</p> <code>convert</code> <p>Callable to convert matched string to Python type.</p> Source code in <code>jetweb/converters.py</code> <pre><code>class BaseConverter:\n    \"\"\"\n    Base class for route parameter converters.\n\n    :var pattern: Regex pattern to match request endpoint.\n    :var identifier: Identifier used in route endpoint.\n    :var convert: Callable to convert matched string to Python type.\n    \"\"\"\n    pattern = None\n    identifier = None\n    convert = None\n</code></pre>"},{"location":"reference/api/converters/#jetweb.converters.FloatConverter","title":"<code>FloatConverter</code>","text":"<p>               Bases: <code>BaseConverter</code></p> <p>Converter for float parameters.</p> Source code in <code>jetweb/converters.py</code> <pre><code>@converter\nclass FloatConverter(BaseConverter):\n    \"\"\"\n    Converter for float parameters.\n    \"\"\"\n    pattern = r\"[\\d.]+\"\n    identifier = \"float\"\n    convert = float\n</code></pre>"},{"location":"reference/api/converters/#jetweb.converters.IntConverter","title":"<code>IntConverter</code>","text":"<p>               Bases: <code>BaseConverter</code></p> <p>Converter for integer parameters.</p> Source code in <code>jetweb/converters.py</code> <pre><code>@converter\nclass IntConverter(BaseConverter):\n    \"\"\"\n    Converter for integer parameters.\n    \"\"\"\n    pattern = r\"\\d+\"\n    identifier = \"int\"\n    convert = int\n</code></pre>"},{"location":"reference/api/converters/#jetweb.converters.PathConverter","title":"<code>PathConverter</code>","text":"<p>               Bases: <code>BaseConverter</code></p> <p>Converter for URL path segments.</p> Source code in <code>jetweb/converters.py</code> <pre><code>@converter\nclass PathConverter(BaseConverter):\n    \"\"\"\n    Converter for URL path segments.\n    \"\"\"\n    pattern = r\"[\\w/]+\"\n    identifier = \"path\"\n    convert = str\n</code></pre>"},{"location":"reference/api/converters/#jetweb.converters.StringConverter","title":"<code>StringConverter</code>","text":"<p>               Bases: <code>BaseConverter</code></p> <p>Converter for alphanumeric strings.</p> Source code in <code>jetweb/converters.py</code> <pre><code>@converter\nclass StringConverter(BaseConverter):\n    \"\"\"\n    Converter for alphanumeric strings.\n    \"\"\"\n    pattern = r\"\\w+\"\n    identifier = \"str\"\n    convert = str\n</code></pre>"},{"location":"reference/api/converters/#jetweb.converters.converter","title":"<code>converter(converter)</code>","text":"<p>Register a converter class in the global registry.</p> <p>Parameters:</p> Name Type Description Default <code>converter</code> <code>Type[BaseConverter]</code> <p>A subclass of BaseConverter.</p> required <p>Returns:</p> Type Description <code>Type[BaseConverter]</code> <p>The same converter class.</p> Source code in <code>jetweb/converters.py</code> <pre><code>def converter(converter: Type[BaseConverter]) -&gt; Type[BaseConverter]:\n    \"\"\"\n    Register a converter class in the global registry.\n\n    :param converter: A subclass of BaseConverter.\n    :returns: The same converter class.\n    \"\"\"\n    if not all([converter.pattern, converter.identifier, converter.convert]):\n        raise ValueError(\"Converter must contain pattern, identifier and convert\")\n\n    CONVERTERS[converter.identifier] = converter\n    return converter\n</code></pre>"},{"location":"reference/api/exceptions/","title":"exceptions.py","text":"<p>Provides HTTPException class for error handling.</p>"},{"location":"reference/api/exceptions/#jetweb.exceptions.HTTPException","title":"<code>HTTPException</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Response</code>, <code>Exception</code></p> <p>Exception that also acts as a valid HTTP response.</p> Source code in <code>jetweb/exceptions.py</code> <pre><code>@dataclass\nclass HTTPException(Response, Exception):  # noqa: N818\n    \"\"\"\n    Exception that also acts as a valid HTTP response.\n    \"\"\"\n    status: int = 400\n\n    def __post_init__(self):\n        if not self.content:\n            self.content = HTTPStatus(self.status).description\n        super().__post_init__()\n\n    @classmethod\n    def from_exception(cls, exception: BaseException, catch_traceback: bool) -&gt; HTTPException:\n        \"\"\"\n        Convert any exception into an HTTPException.\n\n        :param exception: Original exception.\n        :param catch_traceback: Include traceback text if True.\n        :returns: HTTPException object.\n        \"\"\"\n        if isinstance(exception, cls):\n            return exception\n        return cls(\n            content=format_exception(exception) if catch_traceback else None,\n            status=500,\n        )\n</code></pre>"},{"location":"reference/api/exceptions/#jetweb.exceptions.HTTPException.from_exception","title":"<code>from_exception(exception, catch_traceback)</code>  <code>classmethod</code>","text":"<p>Convert any exception into an HTTPException.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>BaseException</code> <p>Original exception.</p> required <code>catch_traceback</code> <code>bool</code> <p>Include traceback text if True.</p> required <p>Returns:</p> Type Description <code>HTTPException</code> <p>HTTPException object.</p> Source code in <code>jetweb/exceptions.py</code> <pre><code>@classmethod\ndef from_exception(cls, exception: BaseException, catch_traceback: bool) -&gt; HTTPException:\n    \"\"\"\n    Convert any exception into an HTTPException.\n\n    :param exception: Original exception.\n    :param catch_traceback: Include traceback text if True.\n    :returns: HTTPException object.\n    \"\"\"\n    if isinstance(exception, cls):\n        return exception\n    return cls(\n        content=format_exception(exception) if catch_traceback else None,\n        status=500,\n    )\n</code></pre>"},{"location":"reference/api/handlers/","title":"handlers.py","text":"<p>Provides base class for class-based handlers.</p>"},{"location":"reference/api/handlers/#jetweb.handlers.BaseHandler","title":"<code>BaseHandler</code>","text":"<p>Base class for class-based handlers.</p> Source code in <code>jetweb/handlers.py</code> <pre><code>class BaseHandler:\n    \"\"\"\n    Base class for class-based handlers.\n    \"\"\"\n\n    def dispatch(self, context: Context) -&gt; Union[Response, object]:\n        \"\"\"\n        Dispatch request to appropriate HTTP method handler.\n\n        :param context: Context values for current request.\n        :returns: Handler return value (Response or any object).\n        :raises HTTPException(405): If method is not implemented.\n        \"\"\"\n        handler = getattr(self, context[\"request\"].method.lower(), None)\n        if handler:\n            return handler(**context.params_for(handler))\n        raise HTTPException(status=405)\n</code></pre>"},{"location":"reference/api/handlers/#jetweb.handlers.BaseHandler.dispatch","title":"<code>dispatch(context)</code>","text":"<p>Dispatch request to appropriate HTTP method handler.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>Context values for current request.</p> required <p>Returns:</p> Type Description <code>Union[Response, object]</code> <p>Handler return value (Response or any object).</p> <p>Raises:</p> Type Description <code>HTTPException(405)</code> <p>If method is not implemented.</p> Source code in <code>jetweb/handlers.py</code> <pre><code>def dispatch(self, context: Context) -&gt; Union[Response, object]:\n    \"\"\"\n    Dispatch request to appropriate HTTP method handler.\n\n    :param context: Context values for current request.\n    :returns: Handler return value (Response or any object).\n    :raises HTTPException(405): If method is not implemented.\n    \"\"\"\n    handler = getattr(self, context[\"request\"].method.lower(), None)\n    if handler:\n        return handler(**context.params_for(handler))\n    raise HTTPException(status=405)\n</code></pre>"},{"location":"reference/api/reference/","title":"Reference","text":"<ul> <li>application.py</li> <li>context.py</li> <li>converters.py</li> <li>exceptions.py</li> <li>handlers.py</li> <li>http<ul> <li>request.py</li> <li>response.py</li> </ul> </li> <li>routing<ul> <li>route.py</li> <li>route_table.py</li> <li>router.py</li> </ul> </li> <li>utils<ul> <li>datastructures.py</li> <li>endpoints.py</li> <li>exceptions.py</li> <li>request.py</li> </ul> </li> </ul>"},{"location":"reference/api/http/request/","title":"request.py","text":"<p>Provides HTTP request representation.</p>"},{"location":"reference/api/http/request/#jetweb.http.request.Request","title":"<code>Request</code>  <code>dataclass</code>","text":"<p>Represents an HTTP request.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Request method (GET, POST, etc.).</p> required <code>endpoint</code> <code>str</code> <p>Request endpoint.</p> required <code>query_params</code> <code>CaseInsensitiveDict</code> <p>Case-insensitive dict of query parameters.</p> required <code>headers</code> <code>CaseInsensitiveDict</code> <p>Case-insensitive dict of headers.</p> required <code>body</code> <code>bytes</code> <p>Request body.</p> required Source code in <code>jetweb/http/request.py</code> <pre><code>@dataclass\nclass Request:\n    \"\"\"\n    Represents an HTTP request.\n\n    :param method: Request method (GET, POST, etc.).\n    :param endpoint: Request endpoint.\n    :param query_params: Case-insensitive dict of query parameters.\n    :param headers: Case-insensitive dict of headers.\n    :param body: Request body.\n    \"\"\"\n    method: str\n    endpoint: str\n    query_params: CaseInsensitiveDict\n    headers: CaseInsensitiveDict\n    body: bytes\n\n    @property\n    def text(self) -&gt; str:\n        \"\"\"\n        Parse body as text.\n\n        :returns: Request body decoded as text.\n        \"\"\"\n        return self.body.decode()\n\n    @property\n    def json(self) -&gt; dict:\n        \"\"\"\n        Parse body as JSON.\n\n        :returns: Request body loaded as JSON.\n        :raises ValueError: If content-type is not application/json.\n        \"\"\"\n        if self.headers[\"content-type\"] != \"application/json\":\n            raise ValueError(\"Content type must be application/json\")\n\n        return loads(self.body)\n\n    @classmethod\n    def from_environ(cls, environ: dict) -&gt; Request:\n        \"\"\"\n        Construct a Request object from WSGI environ.\n\n        :param environ: WSGI environ.\n        :returns: Request object.\n        \"\"\"\n        return cls(\n            method=environ[\"REQUEST_METHOD\"],\n            endpoint=environ[\"PATH_INFO\"],\n            query_params=parse_query_params(environ),\n            headers=parse_headers(environ),\n            body=parse_body(environ),\n        )\n</code></pre>"},{"location":"reference/api/http/request/#jetweb.http.request.Request.json","title":"<code>json</code>  <code>property</code>","text":"<p>Parse body as JSON.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Request body loaded as JSON.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If content-type is not application/json.</p>"},{"location":"reference/api/http/request/#jetweb.http.request.Request.text","title":"<code>text</code>  <code>property</code>","text":"<p>Parse body as text.</p> <p>Returns:</p> Type Description <code>str</code> <p>Request body decoded as text.</p>"},{"location":"reference/api/http/request/#jetweb.http.request.Request.from_environ","title":"<code>from_environ(environ)</code>  <code>classmethod</code>","text":"<p>Construct a Request object from WSGI environ.</p> <p>Parameters:</p> Name Type Description Default <code>environ</code> <code>dict</code> <p>WSGI environ.</p> required <p>Returns:</p> Type Description <code>Request</code> <p>Request object.</p> Source code in <code>jetweb/http/request.py</code> <pre><code>@classmethod\ndef from_environ(cls, environ: dict) -&gt; Request:\n    \"\"\"\n    Construct a Request object from WSGI environ.\n\n    :param environ: WSGI environ.\n    :returns: Request object.\n    \"\"\"\n    return cls(\n        method=environ[\"REQUEST_METHOD\"],\n        endpoint=environ[\"PATH_INFO\"],\n        query_params=parse_query_params(environ),\n        headers=parse_headers(environ),\n        body=parse_body(environ),\n    )\n</code></pre>"},{"location":"reference/api/http/response/","title":"response.py","text":"<p>Provides HTTP response representation.</p>"},{"location":"reference/api/http/response/#jetweb.http.response.Response","title":"<code>Response</code>  <code>dataclass</code>","text":"<p>Represents an HTTP response.</p> <p>Parameters:</p> Name Type Description Default <code>headers</code> <code>dict</code> <p>Response headers.</p> <code>dict()</code> <code>content</code> <code>Any</code> <p>Response body.</p> <code>''</code> <code>status</code> <code>int</code> <p>Response status code.</p> <code>200</code> <code>content_type</code> <code>str</code> <p>MIME type of the response.</p> <code>None</code> Source code in <code>jetweb/http/response.py</code> <pre><code>@dataclass\nclass Response:\n    \"\"\"\n    Represents an HTTP response.\n\n    :param headers: Response headers.\n    :param content: Response body.\n    :param status: Response status code.\n    :param content_type: MIME type of the response.\n    \"\"\"\n    headers: dict = field(default_factory=dict)\n    content: Any = \"\"\n    status: int = 200\n    content_type: str = None\n\n    def __post_init__(self):\n        if not self.content_type:\n            self.content_type = \"text/plain\" if isinstance(self.content, str) else \"application/json\"\n        self.headers[\"Content-Type\"] = self.content_type\n        self.reason = HTTPStatus(self.status).phrase\n\n    @property\n    def body(self) -&gt; bytes:\n        \"\"\"\n        Return body as encoded bytes.\n\n        For responses with content type application/json,\n        the content is first JSON-serialized before encoding.\n\n        :returns: Response body encoded as text.\n        \"\"\"\n        if self.content_type == \"application/json\":\n            return dumps(self.content).encode()\n        return self.content.encode()\n\n    @classmethod\n    def ensure_response(cls, obj: Union[Response, object]) -&gt; Response:\n        \"\"\"\n        Convert any object or Response into a Response.\n\n        :param obj: Response or any object.\n        :returns: Response object.\n        \"\"\"\n        return obj if isinstance(obj, cls) else cls(content=obj)\n</code></pre>"},{"location":"reference/api/http/response/#jetweb.http.response.Response.body","title":"<code>body</code>  <code>property</code>","text":"<p>Return body as encoded bytes.</p> <p>For responses with content type application/json, the content is first JSON-serialized before encoding.</p> <p>Returns:</p> Type Description <code>bytes</code> <p>Response body encoded as text.</p>"},{"location":"reference/api/http/response/#jetweb.http.response.Response.ensure_response","title":"<code>ensure_response(obj)</code>  <code>classmethod</code>","text":"<p>Convert any object or Response into a Response.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Union[Response, object]</code> <p>Response or any object.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>Response object.</p> Source code in <code>jetweb/http/response.py</code> <pre><code>@classmethod\ndef ensure_response(cls, obj: Union[Response, object]) -&gt; Response:\n    \"\"\"\n    Convert any object or Response into a Response.\n\n    :param obj: Response or any object.\n    :returns: Response object.\n    \"\"\"\n    return obj if isinstance(obj, cls) else cls(content=obj)\n</code></pre>"},{"location":"reference/api/routing/route/","title":"route.py","text":"<p>Provides route class.</p>"},{"location":"reference/api/routing/route/#jetweb.routing.route.Route","title":"<code>Route</code>  <code>dataclass</code>","text":"<p>Represents a single route mapping.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Route endpoint. Can contain optional path parameters with converter names.</p> required <code>handler</code> <code>Callable</code> <p>Request handler.</p> required <code>methods</code> <code>Iterable[str]</code> <p>Allowed request methods.</p> required Source code in <code>jetweb/routing/route.py</code> <pre><code>@dataclass\nclass Route:\n    \"\"\"\n    Represents a single route mapping.\n\n    :param endpoint: Route endpoint. Can contain optional path parameters with converter names.\n    :param handler: Request handler.\n    :param methods: Allowed request methods.\n    \"\"\"\n    endpoint: str\n    handler: Callable\n    methods: Iterable[str]\n    _pattern: Pattern = field(init=False, repr=False)\n\n    def __post_init__(self):\n        self.endpoint = normalize_endpoint(self.endpoint)\n        self._pattern = create_pattern(self.endpoint, CONVERTERS)\n\n    def match_endpoint(self, endpoint: str) -&gt; tuple[bool, dict]:\n        \"\"\"\n        Match a request endpoint against this route's pattern.\n\n        :param endpoint: Request endpoint for matching.\n        :returns: True if endpoint is matched and parsed path parameters.\n        \"\"\"\n        match = self._pattern.match(endpoint)\n        path_params = match.groupdict() if match else {}\n\n        return bool(match), convert_path_params(self.endpoint, path_params, CONVERTERS)\n\n    def match_method(self, method: str) -&gt; bool:\n        \"\"\"\n        Match a request method against this route's allowed methods.\n\n        :returns: True if method is matched.\n        \"\"\"\n        return method in self.methods or \"*\" in self.methods\n</code></pre>"},{"location":"reference/api/routing/route/#jetweb.routing.route.Route.match_endpoint","title":"<code>match_endpoint(endpoint)</code>","text":"<p>Match a request endpoint against this route's pattern.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Request endpoint for matching.</p> required <p>Returns:</p> Type Description <code>tuple[bool, dict]</code> <p>True if endpoint is matched and parsed path parameters.</p> Source code in <code>jetweb/routing/route.py</code> <pre><code>def match_endpoint(self, endpoint: str) -&gt; tuple[bool, dict]:\n    \"\"\"\n    Match a request endpoint against this route's pattern.\n\n    :param endpoint: Request endpoint for matching.\n    :returns: True if endpoint is matched and parsed path parameters.\n    \"\"\"\n    match = self._pattern.match(endpoint)\n    path_params = match.groupdict() if match else {}\n\n    return bool(match), convert_path_params(self.endpoint, path_params, CONVERTERS)\n</code></pre>"},{"location":"reference/api/routing/route/#jetweb.routing.route.Route.match_method","title":"<code>match_method(method)</code>","text":"<p>Match a request method against this route's allowed methods.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if method is matched.</p> Source code in <code>jetweb/routing/route.py</code> <pre><code>def match_method(self, method: str) -&gt; bool:\n    \"\"\"\n    Match a request method against this route's allowed methods.\n\n    :returns: True if method is matched.\n    \"\"\"\n    return method in self.methods or \"*\" in self.methods\n</code></pre>"},{"location":"reference/api/routing/route_table/","title":"route_table.py","text":"<p>Provides routing table class.</p>"},{"location":"reference/api/routing/route_table/#jetweb.routing.route_table.RouteTable","title":"<code>RouteTable</code>","text":"<p>Stores and manages registered routes.</p> <p>Provides lookup for handlers based on URL and HTTP method.</p> Source code in <code>jetweb/routing/route_table.py</code> <pre><code>class RouteTable:\n    \"\"\"\n    Stores and manages registered routes.\n\n    Provides lookup for handlers based on URL and HTTP method.\n    \"\"\"\n\n    def __init__(self):\n        self.routes = []\n\n    def include(self, prefix: str, route_table: RouteTable) -&gt; None:\n        \"\"\"\n        Include routes from another table under a prefix.\n\n        :param prefix: Endpoint prefix.\n        :param route_table: Route table with routes for including.\n        \"\"\"\n        for route in route_table.routes:\n            self.routes.append(\n                Route(endpoint=prefix + route.endpoint, handler=route.handler, methods=route.methods)\n            )\n\n    def add_route(\n        self, prefix: str, endpoint: str, handler: Callable, methods: Union[Iterable[str], None] = None\n    ) -&gt; None:\n        \"\"\"\n        Register a new route.\n\n        :param prefix: Endpoint prefix.\n        :param endpoint: Route endpoint.\n        :param handler: Request handler.\n        :param methods: Allowed request methods (default: [\"GET\"]). Adds \"OPTIONS\" if GET is allowed.\n        \"\"\"\n        methods = [method.upper() for method in (methods or [\"GET\"])]\n        if \"GET\" in methods:\n            methods.append(\"OPTIONS\")\n\n        self.routes.append(\n            Route(endpoint=prefix + endpoint, handler=handler, methods=methods)\n        )\n\n    def find_handler(self, endpoint: str, method: str) -&gt; tuple[Callable, dict]:\n        \"\"\"\n        Find a request handler for the given endpoint and method.\n\n        :param endpoint: Request endpoint.\n        :param method: Request method.\n        :returns: Request handler and parsed path parameters.\n        :raises HTTPException(404): If no route matches for endpoint.\n        :raises HTTPException(405): If no method matches for matched route.\n        \"\"\"\n        for route in self.routes:\n            matched, path_params = route.match_endpoint(endpoint)\n            if matched:\n                if route.match_method(method):\n                    return route.handler, path_params\n                raise HTTPException(status=405)\n        raise HTTPException(status=404)\n</code></pre>"},{"location":"reference/api/routing/route_table/#jetweb.routing.route_table.RouteTable.add_route","title":"<code>add_route(prefix, endpoint, handler, methods=None)</code>","text":"<p>Register a new route.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Endpoint prefix.</p> required <code>endpoint</code> <code>str</code> <p>Route endpoint.</p> required <code>handler</code> <code>Callable</code> <p>Request handler.</p> required <code>methods</code> <code>Union[Iterable[str], None]</code> <p>Allowed request methods (default: [\"GET\"]). Adds \"OPTIONS\" if GET is allowed.</p> <code>None</code> Source code in <code>jetweb/routing/route_table.py</code> <pre><code>def add_route(\n    self, prefix: str, endpoint: str, handler: Callable, methods: Union[Iterable[str], None] = None\n) -&gt; None:\n    \"\"\"\n    Register a new route.\n\n    :param prefix: Endpoint prefix.\n    :param endpoint: Route endpoint.\n    :param handler: Request handler.\n    :param methods: Allowed request methods (default: [\"GET\"]). Adds \"OPTIONS\" if GET is allowed.\n    \"\"\"\n    methods = [method.upper() for method in (methods or [\"GET\"])]\n    if \"GET\" in methods:\n        methods.append(\"OPTIONS\")\n\n    self.routes.append(\n        Route(endpoint=prefix + endpoint, handler=handler, methods=methods)\n    )\n</code></pre>"},{"location":"reference/api/routing/route_table/#jetweb.routing.route_table.RouteTable.find_handler","title":"<code>find_handler(endpoint, method)</code>","text":"<p>Find a request handler for the given endpoint and method.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Request endpoint.</p> required <code>method</code> <code>str</code> <p>Request method.</p> required <p>Returns:</p> Type Description <code>tuple[Callable, dict]</code> <p>Request handler and parsed path parameters.</p> <p>Raises:</p> Type Description <code>HTTPException(404)</code> <p>If no route matches for endpoint.</p> <code>HTTPException(405)</code> <p>If no method matches for matched route.</p> Source code in <code>jetweb/routing/route_table.py</code> <pre><code>def find_handler(self, endpoint: str, method: str) -&gt; tuple[Callable, dict]:\n    \"\"\"\n    Find a request handler for the given endpoint and method.\n\n    :param endpoint: Request endpoint.\n    :param method: Request method.\n    :returns: Request handler and parsed path parameters.\n    :raises HTTPException(404): If no route matches for endpoint.\n    :raises HTTPException(405): If no method matches for matched route.\n    \"\"\"\n    for route in self.routes:\n        matched, path_params = route.match_endpoint(endpoint)\n        if matched:\n            if route.match_method(method):\n                return route.handler, path_params\n            raise HTTPException(status=405)\n    raise HTTPException(status=404)\n</code></pre>"},{"location":"reference/api/routing/route_table/#jetweb.routing.route_table.RouteTable.include","title":"<code>include(prefix, route_table)</code>","text":"<p>Include routes from another table under a prefix.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Endpoint prefix.</p> required <code>route_table</code> <code>RouteTable</code> <p>Route table with routes for including.</p> required Source code in <code>jetweb/routing/route_table.py</code> <pre><code>def include(self, prefix: str, route_table: RouteTable) -&gt; None:\n    \"\"\"\n    Include routes from another table under a prefix.\n\n    :param prefix: Endpoint prefix.\n    :param route_table: Route table with routes for including.\n    \"\"\"\n    for route in route_table.routes:\n        self.routes.append(\n            Route(endpoint=prefix + route.endpoint, handler=route.handler, methods=route.methods)\n        )\n</code></pre>"},{"location":"reference/api/routing/router/","title":"router.py","text":"<p>Provides router class.</p>"},{"location":"reference/api/routing/router/#jetweb.routing.router.Router","title":"<code>Router</code>","text":"<p>Router for managing request handling.</p> <p>Supports route, middleware and exception handler registration.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Optional URL prefix for all routes.</p> <code>None</code> Source code in <code>jetweb/routing/router.py</code> <pre><code>class Router:\n    \"\"\"\n    Router for managing request handling.\n\n    Supports route, middleware and exception handler registration.\n\n    :param prefix: Optional URL prefix for all routes.\n    \"\"\"\n\n    def __init__(self, prefix: str = None):\n        self.prefix = prefix or \"\"\n        self.middlewares = []\n        self.exception_handlers = {}\n        self.route_table = RouteTable()\n\n    def include(self, router: Router) -&gt; None:\n        \"\"\"\n        Include routes, middlewares, and handlers from another router.\n\n        :param router: Router for including.\n        \"\"\"\n        self.middlewares.extend(router.middlewares)\n        self.exception_handlers.update(router.exception_handlers)\n        self.route_table.include(self.prefix, router.route_table)\n\n    def add_middleware(self, middleware: Callable) -&gt; None:\n        \"\"\"\n        Register a middleware.\n\n        :param middleware: Middleware.\n        :raises ValueError: If middleware is not callable.\n        \"\"\"\n        if isclass(middleware):\n            middleware = middleware()\n\n        if not callable(middleware):\n            raise ValueError(\"Middleware must be callable\")\n\n        self.middlewares.append(middleware)\n\n    def middleware(self, middleware: Callable) -&gt; Callable:\n        \"\"\"\n        Decorator for registering middleware.\n        \"\"\"\n        self.add_middleware(middleware)\n        return middleware\n\n    def add_exception_handler(self, status: int, exception_handler: Callable) -&gt; None:\n        \"\"\"\n        Register an exception handler for the status.\n\n        :param status: Exception status.\n        :param exception_handler: Exception handler.\n        :raises ValueError: If exception handler is not callable.\n        \"\"\"\n        if not callable(exception_handler):\n            raise ValueError(\"Exception handler must be callable\")\n\n        self.exception_handlers[status] = exception_handler\n\n    def exception_handler(self, status: int) -&gt; Callable:\n        \"\"\"\n        Decorator for registering exception handler.\n        \"\"\"\n        def decorator(exception_handler: Callable) -&gt; Callable:\n            self.add_exception_handler(status, exception_handler)\n            return exception_handler\n        return decorator\n\n    def add_route(self, endpoint: str, handler: Callable, methods: Iterable[str] = None) -&gt; None:\n        \"\"\"\n        Register a request handler for endpoint pattern and allowed methods.\n\n        :param endpoint: Route endpoint.\n        :param handler: Request handler.\n        :param methods: Allowed request methods.\n        :raises ValueError: If class-based handler is not subclass of BaseHandler or handler is not callable.\n        \"\"\"\n        if isclass(handler):\n            if not issubclass(handler, BaseHandler):\n                raise ValueError(\"Class-based handler must be subclass of BaseHandler\")\n\n            handler = handler().dispatch\n            methods = [\"*\"]\n\n        if not callable(handler):\n            raise ValueError(\"Handler must be callable\")\n\n        self.route_table.add_route(self.prefix, endpoint, handler, methods)\n\n    def route(self, endpoint: str, methods: Iterable[str] = None) -&gt; Callable:\n        \"\"\"\n        Decorator for registering request handler.\n        \"\"\"\n        def decorator(handler: Callable) -&gt; Callable:\n            self.add_route(endpoint, handler, methods)\n            return handler\n        return decorator\n\n    def get(self, endpoint: str) -&gt; Callable:\n        \"\"\"\n        Shortcut for @app.route(methods=[\"GET\"]).\n        \"\"\"\n        return self.route(endpoint, [\"GET\"])\n\n    def post(self, endpoint: str) -&gt; Callable:\n        \"\"\"\n        Shortcut for @app.route(methods=[\"POST\"]).\n        \"\"\"\n        return self.route(endpoint, [\"POST\"])\n\n    def put(self, endpoint: str) -&gt; Callable:\n        \"\"\"\n        Shortcut for @app.route(methods=[\"PUT\"]).\n        \"\"\"\n        return self.route(endpoint, [\"PUT\"])\n\n    def patch(self, endpoint: str) -&gt; Callable:\n        \"\"\"\n        Shortcut for @app.route(methods=[\"PATCH\"]).\n        \"\"\"\n        return self.route(endpoint, [\"PATCH\"])\n\n    def delete(self, endpoint: str) -&gt; Callable:\n        \"\"\"\n        Shortcut for @app.route(methods=[\"DELETE\"]).\n        \"\"\"\n        return self.route(endpoint, [\"DELETE\"])\n</code></pre>"},{"location":"reference/api/routing/router/#jetweb.routing.router.Router.add_exception_handler","title":"<code>add_exception_handler(status, exception_handler)</code>","text":"<p>Register an exception handler for the status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>int</code> <p>Exception status.</p> required <code>exception_handler</code> <code>Callable</code> <p>Exception handler.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If exception handler is not callable.</p> Source code in <code>jetweb/routing/router.py</code> <pre><code>def add_exception_handler(self, status: int, exception_handler: Callable) -&gt; None:\n    \"\"\"\n    Register an exception handler for the status.\n\n    :param status: Exception status.\n    :param exception_handler: Exception handler.\n    :raises ValueError: If exception handler is not callable.\n    \"\"\"\n    if not callable(exception_handler):\n        raise ValueError(\"Exception handler must be callable\")\n\n    self.exception_handlers[status] = exception_handler\n</code></pre>"},{"location":"reference/api/routing/router/#jetweb.routing.router.Router.add_middleware","title":"<code>add_middleware(middleware)</code>","text":"<p>Register a middleware.</p> <p>Parameters:</p> Name Type Description Default <code>middleware</code> <code>Callable</code> <p>Middleware.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If middleware is not callable.</p> Source code in <code>jetweb/routing/router.py</code> <pre><code>def add_middleware(self, middleware: Callable) -&gt; None:\n    \"\"\"\n    Register a middleware.\n\n    :param middleware: Middleware.\n    :raises ValueError: If middleware is not callable.\n    \"\"\"\n    if isclass(middleware):\n        middleware = middleware()\n\n    if not callable(middleware):\n        raise ValueError(\"Middleware must be callable\")\n\n    self.middlewares.append(middleware)\n</code></pre>"},{"location":"reference/api/routing/router/#jetweb.routing.router.Router.add_route","title":"<code>add_route(endpoint, handler, methods=None)</code>","text":"<p>Register a request handler for endpoint pattern and allowed methods.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Route endpoint.</p> required <code>handler</code> <code>Callable</code> <p>Request handler.</p> required <code>methods</code> <code>Iterable[str]</code> <p>Allowed request methods.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If class-based handler is not subclass of BaseHandler or handler is not callable.</p> Source code in <code>jetweb/routing/router.py</code> <pre><code>def add_route(self, endpoint: str, handler: Callable, methods: Iterable[str] = None) -&gt; None:\n    \"\"\"\n    Register a request handler for endpoint pattern and allowed methods.\n\n    :param endpoint: Route endpoint.\n    :param handler: Request handler.\n    :param methods: Allowed request methods.\n    :raises ValueError: If class-based handler is not subclass of BaseHandler or handler is not callable.\n    \"\"\"\n    if isclass(handler):\n        if not issubclass(handler, BaseHandler):\n            raise ValueError(\"Class-based handler must be subclass of BaseHandler\")\n\n        handler = handler().dispatch\n        methods = [\"*\"]\n\n    if not callable(handler):\n        raise ValueError(\"Handler must be callable\")\n\n    self.route_table.add_route(self.prefix, endpoint, handler, methods)\n</code></pre>"},{"location":"reference/api/routing/router/#jetweb.routing.router.Router.delete","title":"<code>delete(endpoint)</code>","text":"<p>Shortcut for @app.route(methods=[\"DELETE\"]).</p> Source code in <code>jetweb/routing/router.py</code> <pre><code>def delete(self, endpoint: str) -&gt; Callable:\n    \"\"\"\n    Shortcut for @app.route(methods=[\"DELETE\"]).\n    \"\"\"\n    return self.route(endpoint, [\"DELETE\"])\n</code></pre>"},{"location":"reference/api/routing/router/#jetweb.routing.router.Router.exception_handler","title":"<code>exception_handler(status)</code>","text":"<p>Decorator for registering exception handler.</p> Source code in <code>jetweb/routing/router.py</code> <pre><code>def exception_handler(self, status: int) -&gt; Callable:\n    \"\"\"\n    Decorator for registering exception handler.\n    \"\"\"\n    def decorator(exception_handler: Callable) -&gt; Callable:\n        self.add_exception_handler(status, exception_handler)\n        return exception_handler\n    return decorator\n</code></pre>"},{"location":"reference/api/routing/router/#jetweb.routing.router.Router.get","title":"<code>get(endpoint)</code>","text":"<p>Shortcut for @app.route(methods=[\"GET\"]).</p> Source code in <code>jetweb/routing/router.py</code> <pre><code>def get(self, endpoint: str) -&gt; Callable:\n    \"\"\"\n    Shortcut for @app.route(methods=[\"GET\"]).\n    \"\"\"\n    return self.route(endpoint, [\"GET\"])\n</code></pre>"},{"location":"reference/api/routing/router/#jetweb.routing.router.Router.include","title":"<code>include(router)</code>","text":"<p>Include routes, middlewares, and handlers from another router.</p> <p>Parameters:</p> Name Type Description Default <code>router</code> <code>Router</code> <p>Router for including.</p> required Source code in <code>jetweb/routing/router.py</code> <pre><code>def include(self, router: Router) -&gt; None:\n    \"\"\"\n    Include routes, middlewares, and handlers from another router.\n\n    :param router: Router for including.\n    \"\"\"\n    self.middlewares.extend(router.middlewares)\n    self.exception_handlers.update(router.exception_handlers)\n    self.route_table.include(self.prefix, router.route_table)\n</code></pre>"},{"location":"reference/api/routing/router/#jetweb.routing.router.Router.middleware","title":"<code>middleware(middleware)</code>","text":"<p>Decorator for registering middleware.</p> Source code in <code>jetweb/routing/router.py</code> <pre><code>def middleware(self, middleware: Callable) -&gt; Callable:\n    \"\"\"\n    Decorator for registering middleware.\n    \"\"\"\n    self.add_middleware(middleware)\n    return middleware\n</code></pre>"},{"location":"reference/api/routing/router/#jetweb.routing.router.Router.patch","title":"<code>patch(endpoint)</code>","text":"<p>Shortcut for @app.route(methods=[\"PATCH\"]).</p> Source code in <code>jetweb/routing/router.py</code> <pre><code>def patch(self, endpoint: str) -&gt; Callable:\n    \"\"\"\n    Shortcut for @app.route(methods=[\"PATCH\"]).\n    \"\"\"\n    return self.route(endpoint, [\"PATCH\"])\n</code></pre>"},{"location":"reference/api/routing/router/#jetweb.routing.router.Router.post","title":"<code>post(endpoint)</code>","text":"<p>Shortcut for @app.route(methods=[\"POST\"]).</p> Source code in <code>jetweb/routing/router.py</code> <pre><code>def post(self, endpoint: str) -&gt; Callable:\n    \"\"\"\n    Shortcut for @app.route(methods=[\"POST\"]).\n    \"\"\"\n    return self.route(endpoint, [\"POST\"])\n</code></pre>"},{"location":"reference/api/routing/router/#jetweb.routing.router.Router.put","title":"<code>put(endpoint)</code>","text":"<p>Shortcut for @app.route(methods=[\"PUT\"]).</p> Source code in <code>jetweb/routing/router.py</code> <pre><code>def put(self, endpoint: str) -&gt; Callable:\n    \"\"\"\n    Shortcut for @app.route(methods=[\"PUT\"]).\n    \"\"\"\n    return self.route(endpoint, [\"PUT\"])\n</code></pre>"},{"location":"reference/api/routing/router/#jetweb.routing.router.Router.route","title":"<code>route(endpoint, methods=None)</code>","text":"<p>Decorator for registering request handler.</p> Source code in <code>jetweb/routing/router.py</code> <pre><code>def route(self, endpoint: str, methods: Iterable[str] = None) -&gt; Callable:\n    \"\"\"\n    Decorator for registering request handler.\n    \"\"\"\n    def decorator(handler: Callable) -&gt; Callable:\n        self.add_route(endpoint, handler, methods)\n        return handler\n    return decorator\n</code></pre>"},{"location":"reference/api/utils/datastructures/","title":"datastructures.py","text":"<p>Provides custom data structures.</p>"},{"location":"reference/api/utils/datastructures/#jetweb.utils.datastructures.CaseInsensitiveDict","title":"<code>CaseInsensitiveDict</code>","text":"<p>               Bases: <code>UserDict</code></p> <p>Dictionary-like object that treats keys as case-insensitive.</p> Source code in <code>jetweb/utils/datastructures.py</code> <pre><code>class CaseInsensitiveDict(UserDict):\n    \"\"\"\n    Dictionary-like object that treats keys as case-insensitive.\n    \"\"\"\n\n    def __getitem__(self, key: str) -&gt; str:\n        return super().__getitem__(key.lower())\n\n    def __setitem__(self, key: str, value: str) -&gt; None:\n        super().__setitem__(key.lower(), value)\n\n    def __delitem__(self, key: str) -&gt; None:\n        super().__delitem__(key.lower())\n</code></pre>"},{"location":"reference/api/utils/endpoints/","title":"endpoints.py","text":"<p>Provides utils for endpoints.</p>"},{"location":"reference/api/utils/endpoints/#jetweb.utils.endpoints.convert_path_params","title":"<code>convert_path_params(endpoint, path_params, converters)</code>","text":"<p>Convert path parameters to necessary types.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Route endpoint.</p> required <code>path_params</code> <code>dict</code> <p>Path parameters.</p> required <code>converters</code> <code>dict</code> <p>Converters for path parameter.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Converted path parameters.</p> Source code in <code>jetweb/utils/endpoints.py</code> <pre><code>def convert_path_params(endpoint: str, path_params: dict, converters: dict) -&gt; dict:\n    \"\"\"\n    Convert path parameters to necessary types.\n\n    :param endpoint: Route endpoint.\n    :param path_params: Path parameters.\n    :param converters: Converters for path parameter.\n    :returns: Converted path parameters.\n    \"\"\"\n    for param_name in path_params:\n        for converter in converters.values():\n            if f\"{param_name}:{converter.identifier}\" in endpoint:\n                path_params[param_name] = converter.convert(path_params[param_name])\n\n    return path_params\n</code></pre>"},{"location":"reference/api/utils/endpoints/#jetweb.utils.endpoints.convert_to_regex","title":"<code>convert_to_regex(match, converters)</code>","text":"<p>Convert a \"{name:type}\" placeholder into a named regex group using converters.</p> <p>Parameters:</p> Name Type Description Default <code>match</code> <code>Match</code> <p>Match object with path parameter.</p> required <code>converters</code> <code>dict</code> <p>Converters for path parameter.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Regex substring for path parameter.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If converter identifier is not known.</p> Source code in <code>jetweb/utils/endpoints.py</code> <pre><code>def convert_to_regex(match: Match, converters: dict) -&gt; str:\n    \"\"\"\n    Convert a \"{name:type}\" placeholder into a named regex group using converters.\n\n    :param match: Match object with path parameter.\n    :param converters: Converters for path parameter.\n    :returns: Regex substring for path parameter.\n    :raises ValueError: If converter identifier is not known.\n    \"\"\"\n    param_name, param_type = match.groups()\n    param_type = (param_type or \"path\").lstrip(\":\")\n\n    if param_type not in converters:\n        raise ValueError(\"Converter must be registered\")\n\n    return f\"(?P&lt;{param_name}&gt;{converters[param_type].pattern})\"\n</code></pre>"},{"location":"reference/api/utils/endpoints/#jetweb.utils.endpoints.create_pattern","title":"<code>create_pattern(endpoint, converters)</code>","text":"<p>Build a compiled regex pattern from a route endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Route endpoint.</p> required <code>converters</code> <code>dict</code> <p>Converters for path parameter.</p> required <p>Returns:</p> Type Description <code>Pattern</code> <p>Pattern object.</p> Source code in <code>jetweb/utils/endpoints.py</code> <pre><code>def create_pattern(endpoint: str, converters: dict) -&gt; Pattern:\n    \"\"\"\n    Build a compiled regex pattern from a route endpoint.\n\n    :param endpoint: Route endpoint.\n    :param converters: Converters for path parameter.\n    :returns: Pattern object.\n    \"\"\"\n    pattern = sub(r\"{(\\w+)(:\\w+)?}\", lambda match: convert_to_regex(match, converters), endpoint)\n    return compile(\"^\" + pattern + \"$\")\n</code></pre>"},{"location":"reference/api/utils/endpoints/#jetweb.utils.endpoints.normalize_endpoint","title":"<code>normalize_endpoint(endpoint)</code>","text":"<p>Add leading slash and remove several sequential slashes.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>Route endpoint.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Normalized route endpoint.</p> Source code in <code>jetweb/utils/endpoints.py</code> <pre><code>def normalize_endpoint(endpoint: str) -&gt; str:\n    \"\"\"\n    Add leading slash and remove several sequential slashes.\n\n    :param endpoint: Route endpoint.\n    :returns: Normalized route endpoint.\n    \"\"\"\n    endpoint = \"/\" + endpoint\n    return sub(r\"/+\", r\"/\", endpoint)\n</code></pre>"},{"location":"reference/api/utils/exceptions/","title":"exceptions.py","text":"<p>Provides utils for exceptions.</p>"},{"location":"reference/api/utils/exceptions/#jetweb.utils.exceptions.format_exception","title":"<code>format_exception(exception)</code>","text":"<p>Format exception with traceback as a string.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>BaseException</code> <p>Original exception.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Exception traceback.</p> Source code in <code>jetweb/utils/exceptions.py</code> <pre><code>def format_exception(exception: BaseException) -&gt; str:\n    \"\"\"\n    Format exception with traceback as a string.\n\n    :param exception: Original exception.\n    :returns: Exception traceback.\n    \"\"\"\n    return \"\".join(traceback.format_exception(type(exception), exception, exception.__traceback__))\n</code></pre>"},{"location":"reference/api/utils/request/","title":"request.py","text":"<p>Provides utils for parsing request data.</p>"},{"location":"reference/api/utils/request/#jetweb.utils.request.parse_body","title":"<code>parse_body(environ)</code>","text":"<p>Extract request body from WSGI environ.</p> Source code in <code>jetweb/utils/request.py</code> <pre><code>def parse_body(environ: dict) -&gt; bytes:\n    \"\"\"\n    Extract request body from WSGI environ.\n    \"\"\"\n    content_length = int(environ.get(\"CONTENT_LENGTH\") or 0)\n    readable = environ[\"wsgi.input\"]\n    return readable.read(content_length)\n</code></pre>"},{"location":"reference/api/utils/request/#jetweb.utils.request.parse_headers","title":"<code>parse_headers(environ)</code>","text":"<p>Extract request headers from WSGI environ.</p> Source code in <code>jetweb/utils/request.py</code> <pre><code>def parse_headers(environ: dict) -&gt; CaseInsensitiveDict:\n    \"\"\"\n    Extract request headers from WSGI environ.\n    \"\"\"\n    filtered_headers = filter(\n        lambda item: item[0].startswith(\"HTTP_\") or item[0] in (\"CONTENT_TYPE\", \"CONTENT_LENGTH\"),\n        environ.items(),\n    )\n    formatted_headers = map(\n        lambda item: (\"-\".join(item[0].replace(\"HTTP_\", \"\").split(\"_\")), item[1]),\n        filtered_headers,\n    )\n    return CaseInsensitiveDict(formatted_headers)\n</code></pre>"},{"location":"reference/api/utils/request/#jetweb.utils.request.parse_query_params","title":"<code>parse_query_params(environ)</code>","text":"<p>Extract request query parameters from WSGI environ.</p> Source code in <code>jetweb/utils/request.py</code> <pre><code>def parse_query_params(environ: dict) -&gt; CaseInsensitiveDict:\n    \"\"\"\n    Extract request query parameters from WSGI environ.\n    \"\"\"\n    return CaseInsensitiveDict(parse_qsl(environ[\"QUERY_STRING\"], True))\n</code></pre>"},{"location":"tutorial/context/","title":"Context","text":""},{"location":"tutorial/context/#dependency-injection","title":"Dependency injection","text":"<p>The Context is a dict\u2011like object that stores request\u2011scoped values. JetWeb creates a separate <code>Context</code> instance for every request and supports automatic parameter injection for handlers and middlewares.</p> <pre><code>from typing import Callable\n\nfrom jetweb import Context, HTTPException, JetWeb, Request, Response\n\ndb = Database()\napp = JetWeb(global_context={\"service_name\": \"example\"})\n\n\n@app.middleware\ndef auth_middleware(next_handler: Callable, request: Request, context: Context) -&gt; Response:\n    token = request.headers.get(\"Authorization\")\n    if not token:\n        raise HTTPException(status=403, content=\"Not authenticated\")\n    context[\"token\"] = token\n    return next_handler()\n\n\n@app.get(\"/profile\")\ndef profile(db: Database, token: str) -&gt; dict:\n    user_id = get_user_id(token)\n    user = db.get_user(user_id)\n    return user\n</code></pre>"},{"location":"tutorial/context/#context-values","title":"Context values","text":"<p>JetWeb can inject the following parameters into handlers and middlewares when they are requested by name in the callable signature:</p> <ul> <li><code>app</code> \u2014 current <code>JetWeb</code> instance.</li> <li><code>request</code> \u2014 current <code>Request</code>.</li> <li><code>exception</code> \u2014 <code>HTTPException</code> (available after raising exception).</li> <li><code>context</code> \u2014 the <code>Context</code> object for the current request; you can add values to it.</li> <li>Path parameters parsed from the route.</li> <li>Global context values passed via <code>JetWeb(global_context=...)</code> are available for each request.</li> </ul>"},{"location":"tutorial/exception-handlers/","title":"Exception Handlers","text":""},{"location":"tutorial/exception-handlers/#http-exceptions","title":"HTTP exceptions","text":"<p>JetWeb represents HTTP errors using <code>HTTPException</code>, which is both an <code>Exception</code> and a valid <code>Response</code>. When you raise <code>HTTPException</code>, the client receives the corresponding response:</p> <pre><code>from jetweb import HTTPException, JetWeb, Request\n\napp = JetWeb()\n\n\n@app.get(\"/hello\")\ndef hello(request: Request) -&gt; None:\n    raise HTTPException(status=403, content=\"Not authenticated\")\n</code></pre> <p>The framework may also raise <code>HTTPException</code> automatically in these cases:</p> <ul> <li><code>HTTPException(status=404)</code> \u2014 no route matched the request endpoint.</li> <li><code>HTTPException(status=405)</code> \u2014 a route matched, but the HTTP method is not allowed.</li> <li><code>HTTPException(status=500)</code> \u2014 any other unhandled exception. When <code>JetWeb(debug=True)</code>   is enabled, the response contains the full traceback.</li> </ul>"},{"location":"tutorial/exception-handlers/#handling-httpexception","title":"Handling <code>HTTPException</code>","text":"<p>You can register handlers for particular HTTP statuses:</p> <pre><code>from jetweb import HTTPException, JetWeb\n\napp = JetWeb()\n\n\n@app.exception_handler(404)\ndef not_found(exception: HTTPException) -&gt; dict:\n    return {\"detail\": \"Route was not found\"}\n</code></pre> <p>\u26a0\ufe0f Warning: Exception handlers mustn't raise any exception because it won't be caught.</p>"},{"location":"tutorial/middlewares/","title":"Middlewares","text":""},{"location":"tutorial/middlewares/#function-middlewares","title":"Function middlewares","text":"<p>Middlewares are callables that can run logic before and/or after the request handler. They also decide whether the rest of the chain is invoked by calling <code>next_handler()</code>.</p> <p>Register a middleware with the <code>@app.middleware</code> decorator:</p> <pre><code>from typing import Callable\n\nfrom jetweb import HTTPException, JetWeb, Request, Response\n\napp = JetWeb()\n\n\n@app.middleware\ndef auth_middleware(next_handler: Callable, request: Request) -&gt; Response:\n    token = request.headers.get(\"Authorization\")\n    if not token:\n        raise HTTPException(status=403, content=\"Not authenticated\")\n    return next_handler()\n</code></pre> <p>Middlewares are called in order of registration before the request handler.</p>"},{"location":"tutorial/middlewares/#class-based-middlewares","title":"Class-based middlewares","text":"<p>Class-based middlewares must implement <code>__call__()</code> method with the same signature and be decorated with <code>@app.middleware</code>:</p> <pre><code>from typing import Callable\n\nfrom jetweb import HTTPException, JetWeb, Request, Response\n\napp = JetWeb()\n\n\n@app.middleware\nclass AuthMiddleware:\n    def __call__(self, next_handler: Callable, request: Request) -&gt; Response:\n        token = request.headers.get(\"Authorization\")\n        if not token:\n            raise HTTPException(status=403, content=\"Not authenticated\")\n        return next_handler()\n</code></pre> <p>The middleware class is instantiated automatically when registered.</p>"},{"location":"tutorial/next-steps/","title":"Next Steps","text":"<p>Now that you\u2019ve completed the basics, you may want to explore Reference section.</p>"},{"location":"tutorial/path-parameters/","title":"Path Parameters","text":""},{"location":"tutorial/path-parameters/#dynamic-endpoints","title":"Dynamic endpoints","text":"<p>Route endpoints can contain dynamic parts:</p> <pre><code>@app.get(\"/hello/{name}\")\ndef hello(request: Request, name: str) -&gt; Response:\n    return Response(content=f\"Hello, {name}!\")\n</code></pre>"},{"location":"tutorial/path-parameters/#converters","title":"Converters","text":"<p>Converters allow you to filter and convert dynamic parts. Specify a converter by its identifier after a colon:</p> <pre><code>@app.get(\"/users/{id:int}\")\ndef get_user(request: Request, id: int) -&gt; dict:\n    return {\"user_id\": id}\n</code></pre> <p>Built\u2011in converters:</p> <ul> <li><code>int</code> \u2014 digits.</li> <li><code>float</code> \u2014 digits and a dot.</li> <li><code>str</code> \u2014 (default) word characters, no slash.</li> <li><code>path</code> \u2014 like <code>str</code>, but also accepts slashes.</li> </ul> <p>To register a custom converter, decorate a class with <code>@converter</code> and (optionally) subclass <code>BaseConverter</code>:</p> <pre><code>from jetweb import BaseConverter, JetWeb, Request, converter\n\napp = JetWeb()\n\n\n@converter\nclass UppercaseConverter(BaseConverter):\n    pattern = r\"[A-Z]+\"   # regex pattern for capturing\n    identifier = \"upper\"  # identifier used in the endpoint\n    convert = str.upper   # function for converting to Python value\n\n\n@app.get(\"/users/{name:upper}\")\ndef get_user(request: Request, name: str) -&gt; dict:\n    return {\"user_name\": name}\n</code></pre>"},{"location":"tutorial/request-handlers/","title":"Request Handlers","text":""},{"location":"tutorial/request-handlers/#function-based-handlers","title":"Function-based handlers","text":"<p>Request handlers are callables that return a <code>Response</code> or any object (which is auto\u2011wrapped in <code>Response</code>). Register handlers using <code>@app.route</code>, <code>@app.get</code>, <code>@app.post</code>, etc.:</p> <pre><code>from jetweb import JetWeb, Request, Response\n\napp = JetWeb()\n\n\n@app.route(\"/hello\", methods=[\"GET\"])\ndef hello(request: Request) -&gt; Response:\n    return Response(content=\"Hello, World!\")\n\n\napp.run()\n</code></pre> <p>If a handler returns a plain object or string, JetWeb wraps it in a <code>Response</code> automatically:</p> <pre><code>@app.get(\"/ping\")\ndef ping(request: Request) -&gt; dict:\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"tutorial/request-handlers/#class-based-handlers","title":"Class-based handlers","text":"<p>Class-based handlers must inherit from <code>BaseHandler</code> and be decorated like function-based handlers. HTTP methods (<code>get</code>, <code>post</code>, etc.) are defined as instance methods:</p> <pre><code>@app.route(\"/hello\")\nclass HelloHandler(BaseHandler):\n    def get(self, request: Request) -&gt; str:\n        return \"Hello from GET!\"\n\n    def post(self, request: Request) -&gt; str:\n        return \"Hello from POST!\"\n</code></pre>"},{"location":"tutorial/routers/","title":"Routers","text":"<p>JetWeb provides a <code>Router</code> that lets you register handlers and middlewares. Routers can be included into other routers or into the application under a prefix, which enables modular route grouping:</p> <pre><code>from jetweb import JetWeb, Router\n\napp = JetWeb()\napi_v1 = Router(prefix=\"/api/v1\")\n\n\n@api_v1.get(\"/status\")\ndef status() -&gt; dict:\n    return {\"ok\": True}\n\n\napp.include(api_v1)  # route becomes available at /api/v1/status\n</code></pre>"}]}